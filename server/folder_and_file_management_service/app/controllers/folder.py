from sqlmodel import Session, select
from fastapi import HTTPException
from ..models.folder import FolderDB
from app.schemas.folder import FolderCreate, FolderRead, FolderUpdate
from app.models.folderManager import FolderManager
from app.controllers.getProjectController import get_project_logic

import os
from pathlib import Path
import uuid
import re


SCRIPT_DIR = Path(__file__).resolve().parent
DEFAULT_FOLDER_PATH = SCRIPT_DIR.parent.parent /"storage"

"""Create a folder in the filesystem and link it to a project in the DB."""
def _sanitize_name(name: str) -> str:
    # Keep only safe filename characters, replace others with underscore
    safe = re.sub(r'[^A-Za-z0-9._-]', '_', name)
    return safe[:255] if len(safe) > 255 else safe


def _unique_path(base: Path) -> Path:
    # If base exists, append a numeric suffix to make it unique
    if not base.exists():
        return base
    stem = base.stem
    parent = base.parent
    suffix = base.suffix
    counter = 1
    while True:
        candidate = parent / f"{stem}_{counter}{suffix}"
        if not candidate.exists():
            return candidate
        counter += 1


def _create_filesystem_folder(
    folder_data: dict, 
    projectid: str
) -> Path:
    """
    Determines the unique folder path, creates the physical directory on disk,
    and returns the absolute Path object.
    """
    
    # Determine a safe folder name:
    raw_name = None
    # Common possible name fields - check them in order
    for key in ("name", "title", "folder_name", "dirname"):
        if key in folder_data and folder_data.get(key):
            raw_name = str(folder_data.get(key))
            break

    if not raw_name:
        # fallback to a generated name
        raw_name = f"folder_{uuid.uuid4().hex[:8]}"

    # 1. Sanitize name and define project path
    safe_name = _sanitize_name(Path(raw_name).name)
    project_dir = DEFAULT_FOLDER_PATH / str(projectid)
    target_folder = project_dir / safe_name
    
    # 2. Ensure uniqueness (don't overwrite existing folder)
    target_folder = _unique_path(target_folder)

    # 3. Create the folder on disk
    try:
        # parents=True creates the project_dir if it doesn't exist
        # exist_ok=False raises an error if the unique path was somehow not unique
        target_folder.mkdir(parents=True, exist_ok=False)
    except Exception as exc:
        # Raise HTTPException for upstream API handling
        raise HTTPException(status_code=500, detail=f"Unable to create folder on disk: {exc}")

    return target_folder

def create_folder_in_project(
    folder_data: FolderCreate,
    projectid: str,
    db: Session
) -> FolderRead:
    # 1. Validate project exists
    get_project_logic(projectid)

    # 2. Prepare folder metadata (ignore provided id)
    folder_dict = folder_data.model_dump(exclude={"id"})
    
    # 3. Create the folder on disk and get its final path
    # This is the call to the new helper function
    target_folder = _create_filesystem_folder(folder_dict, projectid) 

    # 4. Save folder record in DB
    db_folder = FolderDB(**folder_dict)  # id will be autogenerated by DB
    
    # Set the path field on the DB model
    fs_path = str(target_folder.resolve())
    # Loop over common path attributes to set the path (uses the existing logic)
    for attr in ("path", "directory", "dir", "location", "filepath"):
        if hasattr(db_folder, attr):
            try:
                setattr(db_folder, attr, fs_path)
            except Exception:
                pass

    db.add(db_folder)
    db.commit()
    db.refresh(db_folder)

    # 5. Link folder to project
    link = FolderManager(folderId=db_folder.id, projectid=projectid)
    db.add(link)
    db.commit()

    return FolderRead.from_orm(db_folder)


def create_folder_logic(folder_in: FolderCreate, db: Session) -> FolderRead:
    db_folder = FolderDB(**folder_in.model_dump())
    db.add(db_folder)
    db.commit()
    db.refresh(db_folder)
    return FolderRead.from_orm(db_folder)


def get_folder_logic(folder_id: int, db: Session) -> FolderRead:
    stmt = select(FolderDB).where(FolderDB.id == folder_id)
    db_folder = db.exec(stmt).first()
    if not db_folder:
        raise HTTPException(status_code=404, detail="Folder not found")
    return FolderRead.from_orm(db_folder)


def list_folders_logic(db: Session, skip: int = 0, limit: int = 100) -> list[FolderRead]:
    stmt = select(FolderDB).offset(skip).limit(limit)
    folders = db.exec(stmt).all()
    return [FolderRead.from_orm(f) for f in folders]


def update_folder_logic(folder_id: int, folder_up: FolderUpdate, db: Session) -> FolderRead:
    db_folder = db.get(FolderDB, folder_id)
    if not db_folder:
        raise HTTPException(status_code=404, detail="Folder not found")
    
    data = folder_up.model_dump(exclude_unset=True)
    for k, v in data.items():
        setattr(db_folder, k, v)
    
    db.add(db_folder)
    db.commit()
    db.refresh(db_folder)
    return FolderRead.from_orm(db_folder)


def delete_folder_logic(folder_id: int, db: Session):
    db_folder = db.get(FolderDB, folder_id)
    if not db_folder:
        raise HTTPException(status_code=404, detail="Folder not found")
    db.delete(db_folder)
    db.commit()